<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>تحويل ملف ووردبريس إلى بلوجر</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
  <div class="bg-white p-8 rounded-lg shadow-lg max-w-md w-full">
    <h1 class="text-2xl font-bold mb-6 text-center text-blue-600">تحويل ملف ووردبريس إلى بلوجر</h1>
    <div class="mb-4">
      <label class="block text-gray-700 mb-2 font-medium" for="xmlFile">اختر ملف XML (ووردبريس):</label>
      <input type="file" id="xmlFile" accept=".xml" class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
    </div>
    <div class="mb-4">
      <label class="block text-gray-700 mb-2 font-medium" for="imagePath">مسار استضافة الصور (اختياري):</label>
      <input type="text" id="imagePath" placeholder="مثال: https://your-host.com/images/" class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
    </div>
    <button id="convertBtn" class="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 transition duration-200">تحويل وتنزيل</button>
    <p id="status" class="mt-4 text-center text-gray-600"></p>
  </div>

  <!-- مكتبة xml2json (الإصدار 1.1.0) مدمجة مباشرة -->
  <script>
    function X2JS(config) {
      "use strict";
      function initConfigDefaults() {
        void 0 === config.escapeMode && (config.escapeMode = !0),
        void 0 === config.attributePrefix && (config.attributePrefix = "_"),
        void 0 === config.arrayAccessForm && (config.arrayAccessForm = "none");
      }
      function getNodeLocalName(node) {
        var nodeLocalName = node.localName;
        return null == nodeLocalName && (nodeLocalName = node.baseName),
        (null == nodeLocalName || "" == nodeLocalName) && (nodeLocalName = node.nodeName),
        nodeLocalName;
      }
      function getNodePrefix(node) {
        return node.prefix;
      }
      function escapeXmlChars(str) {
        return "string" == typeof str ? str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;") : str;
      }
      function unescapeXmlChars(str) {
        return str.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&#x2F;/g, "/");
      }
      function toArrayAccessForm(obj, childName) {
        switch (config.arrayAccessForm) {
          case "property":
            obj[childName] instanceof Array ? obj[childName + "_asArray"] = obj[childName] : obj[childName + "_asArray"] = [obj[childName]];
        }
      }
      function parseDOMChildren(node) {
        if (node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
          var result = new Object,
              child = node.firstChild,
              childName = getNodeLocalName(child);
          return result[childName] = parseDOMChildren(child), result;
        }
        if (node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
          var result = new Object;
          result.__cnt = 0;
          for (var nodeChildren = node.childNodes, cidx = 0; cidx < nodeChildren.length; cidx++) {
            var child = nodeChildren.item(cidx),
                childName = getNodeLocalName(child);
            if (result.__cnt++,
                null == result[childName])
              result[childName] = parseDOMChildren(child),
              toArrayAccessForm(result, childName);
            else {
              if (null != result[childName] && !(result[childName] instanceof Array)) {
                var tmpObj = result[childName];
                result[childName] = new Array,
                result[childName][0] = tmpObj,
                toArrayAccessForm(result, childName);
              }
              for (var aridx = 0; null != result[childName][aridx];) aridx++;
              result[childName][aridx] = parseDOMChildren(child);
            }
          }
          for (var aidx = 0; aidx < node.attributes.length; aidx++) {
            var attr = node.attributes.item(aidx);
            result.__cnt++,
            result[config.attributePrefix + attr.name] = attr.value;
          }
          var nodePrefix = getNodePrefix(node);
          return null != nodePrefix && "" != nodePrefix && (result.__cnt++, result.__prefix = nodePrefix),
          1 == result.__cnt && null != result["#text"] && (result = result["#text"]),
          null != result["#text"] && (result.__text = result["#text"],
            result.__text instanceof Array && (result.__text = result.__text.join("\n")),
            config.escapeMode && (result.__text = unescapeXmlChars(result.__text)),
            delete result["#text"],
            delete result["#text_asArray"]),
          null != result["#cdata-section"] && (result.__cdata = result["#cdata-section"],
            delete result["#cdata-section"],
            delete result["#cdata-section_asArray"]),
          void 0 != result.__cnt && delete result.__cnt,
          (null != result.__text || null != result.__cdata) && (result.toString = function() {
            return (null != this.__text ? this.__text : "") + (null != this.__cdata ? this.__cdata : "");
          }),
          result;
        }
        return node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE ? node.nodeValue : void 0;
      }
      function startTag(jsonObj, element, attrList, closed) {
        var resultStr = "<" + (null != jsonObj && null != jsonObj.__prefix ? jsonObj.__prefix + ":" : "") + element;
        if (null != attrList)
          for (var aidx = 0; aidx < attrList.length; aidx++) {
            var attrName = attrList[aidx],
                attrVal = jsonObj[attrName];
            resultStr += " " + attrName.substr(1) + "='" + attrVal + "'";
          }
        return resultStr += closed ? "/>" : ">";
      }
      function endTag(jsonObj, elementName) {
        return "</" + (null != jsonObj.__prefix ? jsonObj.__prefix + ":" : "") + elementName + ">";
      }
      function endsWith(str, suffix) {
        return -1 !== str.indexOf(suffix, str.length - suffix.length);
      }
      function jsonXmlSpecialElem(jsonObj, jsonObjField) {
        return "property" == config.arrayAccessForm && endsWith(jsonObjField.toString(), "_asArray") || 0 == jsonObjField.toString().indexOf(config.attributePrefix) || 0 == jsonObjField.toString().indexOf("__") || jsonObj[jsonObjField] instanceof Function ? !0 : !1;
      }
      function jsonXmlElemCount(jsonObj) {
        var elementsCnt = 0;
        if (jsonObj instanceof Object)
          for (var it in jsonObj)
            jsonXmlSpecialElem(jsonObj, it) || elementsCnt++;
        return elementsCnt;
      }
      function parseJSONAttributes(jsonObj) {
        var attrList = [];
        if (jsonObj instanceof Object)
          for (var ait in jsonObj)
            -1 == ait.toString().indexOf("__") && 0 == ait.toString().indexOf(config.attributePrefix) && attrList.push(ait);
        return attrList;
      }
      function parseJSONTextAttrs(jsonTxtObj) {
        var result = "";
        return null != jsonTxtObj.__cdata && (result += "<![CDATA[" + jsonTxtObj.__cdata + "]]>"),
        null != jsonTxtObj.__text && (result += config.escapeMode ? escapeXmlChars(jsonTxtObj.__text) : jsonTxtObj.__text),
        result;
      }
      function parseJSONTextObject(jsonTxtObj) {
        var result = "";
        return jsonTxtObj instanceof Object ? result += parseJSONTextAttrs(jsonTxtObj) : null != jsonTxtObj && (result += config.escapeMode ? escapeXmlChars(jsonTxtObj) : jsonTxtObj),
        result;
      }
      function parseJSONArray(jsonArrRoot, jsonArrObj, attrList) {
        var result = "";
        if (0 == jsonArrRoot.length)
          result += startTag(jsonArrRoot, jsonArrObj, attrList, !0);
        else
          for (var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++)
            result += startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), !1),
            result += parseJSONObject(jsonArrRoot[arIdx]),
            result += endTag(jsonArrRoot[arIdx], jsonArrObj);
        return result;
      }
      function parseJSONObject(jsonObj) {
        var result = "",
            elementsCnt = jsonXmlElemCount(jsonObj);
        if (elementsCnt > 0)
          for (var it in jsonObj)
            if (!jsonXmlSpecialElem(jsonObj, it)) {
              var subObj = jsonObj[it],
                  attrList = parseJSONAttributes(subObj);
              if (null == subObj || void 0 == subObj)
                result += startTag(subObj, it, attrList, !0);
              else if (subObj instanceof Object)
                if (subObj instanceof Array)
                  result += parseJSONArray(subObj, it, attrList);
                else {
                  var subObjElementsCnt = jsonXmlElemCount(subObj);
                  subObjElementsCnt > 0 || null != subObj.__text || null != subObj.__cdata ? (result += startTag(subObj, it, attrList, !1),
                    result += parseJSONObject(subObj),
                    result += endTag(subObj, it)) : result += startTag(subObj, it, attrList, !0);
                }
              else
                result += startTag(subObj, it, attrList, !1),
                result += parseJSONTextObject(subObj),
                result += endTag(subObj, it);
            }
        return result += parseJSONTextObject(jsonObj);
      }
      var VERSION = "1.1.0";
      config = config || {},
      initConfigDefaults();
      var DOMNodeTypes = {
        ELEMENT_NODE: 1,
        TEXT_NODE: 3,
        CDATA_SECTION_NODE: 4,
        DOCUMENT_NODE: 9
      };
      this.parseXmlString = function(xmlDocStr) {
        if (void 0 === xmlDocStr)
          return null;
        var xmlDoc;
        if (window.DOMParser) {
          var parser = new window.DOMParser;
          xmlDoc = parser.parseFromString(xmlDocStr, "text/xml");
        } else
          0 == xmlDocStr.indexOf("<?") && (xmlDocStr = xmlDocStr.substr(xmlDocStr.indexOf("?>") + 2)),
          xmlDoc = new ActiveXObject("Microsoft.XMLDOM"),
          xmlDoc.async = "false",
          xmlDoc.loadXML(xmlDocStr);
        return xmlDoc;
      },
      this.asArray = function(prop) {
        return prop instanceof Array ? prop : [prop];
      },
      this.xml2json = function(xmlDoc) {
        return parseDOMChildren(xmlDoc);
      },
      this.xml_str2json = function(xmlDocStr) {
        var xmlDoc = this.parseXmlString(xmlDocStr);
        return this.xml2json(xmlDoc);
      },
      this.json2xml_str = function(jsonObj) {
        return parseJSONObject(jsonObj);
      },
      this.json2xml = function(jsonObj) {
        var xmlDocStr = this.json2xml_str(jsonObj);
        return this.parseXmlString(xmlDocStr);
      },
      this.getVersion = function() {
        return VERSION;
      };
    }
    const x2js = new X2JS();
    const xml2json = x2js.xml2json.bind(x2js);
  </script>

  <!-- مكتبة FileSaver.js المحدثة -->
  <script>
    (function(global) {
      function saveAs(blob, name) {
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = name || 'download';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => window.URL.revokeObjectURL(url), 100);
      }
      global.saveAs = saveAs;
    })(this);
  </script>

  <!-- الكود الرئيسي لتحويل الملف -->
  <script>
    document.getElementById('convertBtn').addEventListener('click', async () => {
      const fileInput = document.getElementById('xmlFile');
      const imagePath = document.getElementById('imagePath').value;
      const status = document.getElementById('status');

      if (!fileInput.files.length) {
        status.textContent = 'يرجى اختيار ملف XML!';
        status.className = 'mt-4 text-center text-red-600';
        return;
      }

      if (typeof xml2json === 'undefined') {
        status.textContent = 'خطأ: مكتبة xml2json غير متاحة.';
        status.className = 'mt-4 text-center text-red-600';
        return;
      }
      if (typeof saveAs === 'undefined') {
        status.textContent = 'خطأ: مكتبة FileSaver غير متاحة.';
        status.className = 'mt-4 text-center text-red-600';
        return;
      }

      status.textContent = 'جارٍ المعالجة...';
      status.className = 'mt-4 text-center text-blue-600';
      const file = fileInput.files[0];
      const reader = new FileReader();

      reader.onload = async (e) => {
        try {
          const xmlText = e.target.result;
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

          const json = xml2json(xmlDoc);
          const channel = json.rss?.channel || {};
          const posts = channel.item || [];
          const blogTitle = channel.title || 'Converted Blog';
          const blogLink = channel.link || 'https://example.com';
          const updatedDate = channel.lastBuildDate || new Date().toISOString();

          if (!Array.isArray(posts) && !posts.title) {
            status.textContent = 'خطأ: لا توجد منشورات في الملف!';
            status.className = 'mt-4 text-center text-red-600';
            return;
          }

          const postsArray = Array.isArray(posts) ? posts : [posts];

          let atomXml = `<?xml version="1.0" encoding="UTF-8"?>
<ns0:feed xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
  <ns0:title type="html">${blogTitle}</ns0:title>
  <ns0:updated>${updatedDate}</ns0:updated>
  <ns0:id>tag:blogger.com,1999:blog-converted</ns0:id>
  <ns0:generator>Blogger</ns0:generator>
  <ns0:link rel="self" href="${blogLink}" type="application/atom+xml"/>
  <ns0:link rel="alternate" href="${blogLink}" type="text/html"/>`;

          postsArray.forEach((post, index) => {
            const title = post.title || 'بدون عنوان';
            let content = post['content:encoded'] || post.description || '';
            const pubDate = post.pubDate || new Date().toISOString();
            const postId = `post-${index + 1}`;
            const author = post['dc:creator'] || 'Unknown';
            const postLink = post.link || blogLink;
            let categories = Array.isArray(post.category) ? post.category : post.category ? [post.category] : [];

            categories = [
              ...categories,
              'http://schemas.google.com/blogger/2008/kind#post',
              'Sin categoría'
            ];

            if (imagePath) {
              content = content.replace(/(<img[^>]+src=")([^"]+)(")/gi, (match, p1, p2, p3) => {
                if (p2.startsWith('http://') || p2.startsWith('https://')) {
                  return match;
                }
                return `${p1}${imagePath}${p2}${p3}`;
              });
            }

            content = content.replace(/ /g, ' ').replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

            atomXml += `
  <ns0:entry>
    <ns0:id>tag:blogger.com,1999:${postId}</ns0:id>
    <ns0:published>${pubDate}</ns0:published>
    <ns0:updated>${pubDate}</ns0:updated>
    <ns0:title type="text">${title}</ns0:title>
    <ns0:content type="html"><![CDATA[${content}]]></ns0:content>
    <ns0:author><ns0:name>${author}</ns0:name></ns0:author>
    ${categories.map(cat => `<ns0:category term="${cat}" ${cat.startsWith('http') ? `scheme="${cat.split('#')[0]}"` : ''}/>`).join('')}
    <ns0:link rel="self" href="${postLink}" type="application/atom+xml"/>
    <ns0:link rel="alternate" href="${postLink}" type="text/html"/>
    <thr:total>0</thr:total>
  </ns0:entry>`;
          });

          atomXml += `</ns0:feed>`;

          const blob = new Blob([atomXml], { type: 'application/xml' });
          if (blob.size > 1 * 1024 * 1024) {
            status.textContent = 'تحذير: الملف كبير جدًا (>1MB). يرجى تقسيم المحتوى يدويًا.';
            status.className = 'mt-4 text-center text-orange-600';
            return;
          }

          saveAs(blob, 'blogger_export.xml');
          status.textContent = 'تم التحويل بنجاح! الملف جاهز للتنزيل.';
          status.className = 'mt-4 text-center text-green-600';
        } catch (error) {
          status.textContent = 'خطأ أثناء التحويل: ' + error.message;
          status.className = 'mt-4 text-center text-red-600';
          console.error(error);
        }
      };

      reader.readAsText(file);
    });
  </script>
</body>
</html>
